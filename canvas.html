<!doctype html>
<html lang="en">

<head>
    <title>BFFrameAnimator-js</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
        crossorigin="anonymous">

    <style>
    .component {
        margin-top: 5px;
        margin-bottom: 15px;
        border: 1px black solid;
        border-radius: 5px;
        min-height: 100px;
        overflow-x: hidden;
    }

    .component .row {
        margin: 0;
    }
    </style>
</head>

<body>
    <div class="container">
        <div class="component">
            <div class="row">
                <h1 class="col text-center">Sprite Sheet</h1>
            </div>
            <div class="row justify-content-center" id="sheetContainer">
                <img>
            </div>
        </div>

        <div class="component">
            <div class="row">
                <h1 class="col text-center">Frame Parts</h1>
            </div>
            <div class="row justify-content-center" id="partContainer">
            </div>
        </div>

        <div class="component">
            <div class="row">
                <h1 class="col text-center">Finished Frames</h1>
            </div>
            <div class="row justify-content-center" id="frameContainer">
            </div>
        </div>
    </div>

    
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"
        crossorigin="anonymous"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        const filepaths = {
            cgg: 'test',
            cgs: 'test',
            anime: 'test'
        }

        const cgsTypes = ['idle', 'move', 'atk'];

        let animationInfo = {
            sheet: undefined,
            id: '10011',
            cgg: [], //individual frame info
            cgs: {} //frame info keyed by animation type
        };

        function loadCSV(path){
            return new Promise((fulfill,reject) => {
                // d3.csv(path,(err,data) => {
                //     err ? reject(err) : fulfill(data);
                // });
                try{
                    $.get(path,function(data){
                        let csv = data.split('\n').map((line) => {
                            return line.split(',').map(d => +d);
                        })
                        fulfill(csv);
                    })
                }catch(err){
                    reject(err);
                }
            });
        }

        function handleSpritesheetLoad(){
            console.log("Loaded",animationInfo.sheet.attr('src'));
            
            let cggPromise = loadCSV(`${filepaths.cgg}/unit_cgg_${animationInfo.id}.csv`)
                .then((data) => {
                    animationInfo.cgg = [];
                    for(let frame of data){
                        if(frame.length < 2){
                            console.log("encountered empty frame, skipping");
                            continue;
                        }
                        let cgg = {};
                        cgg.anchorType = +frame[0];
                        cgg.part_count = +frame[1];
                        cgg.frame_data = [];

                        let curIndex = 2
                        while(curIndex < data.length){
                            let frameInfo = {};
                            frameInfo.position = { //origin is middle
                                x: +frame[curIndex++],
                                y: +frame[curIndex++]
                            };
                            frameInfo.next_type = +frame[curIndex++];
                            frameInfo.blend_mode = +frame[curIndex++];
                            frameInfo.opacity = +frame[curIndex++];
                            frameInfo.rotate = +frame[curIndex++];
                            frameInfo.img = { //origin is top left
                                x: +frame[curIndex++],
                                y: +frame[curIndex++],
                                width: +frame[curIndex++],
                                height: +frame[curIndex++],
                            },
                            frameInfo.page_id = +frame[curIndex++];
                            cgg.frame_data.push(frameInfo);
                        }
                        animationInfo.cgg.push(cgg);
                    }
                    
                    
                    
                });

            let cgsPromises = [];
            for(let c of cgsTypes){
                let curPromise = loadCSV(`${filepaths.cgs}/unit_${c}_cgs_${animationInfo.id}.csv`)
                    .then((data) => {
                        animationInfo.cgs[c] = [];
                        for(let frame of data){
                            let frameInfo = {};
                            frameInfo.frame_index = +frame[0];
                            frameInfo.x_pos_offset = +frame[1];
                            frameInfo.y_pos_offset = +frame[2];
                            frameInfo.frame_delay = +frame[3];
                            animationInfo.cgs[c].push(frameInfo);
                        }

                    }).catch((err) => {
                        console.log(err);
                        return "";
                    });
                cgsPromises.push(curPromise);
            }

            return Promise.all([cggPromise,...cgsPromises])
                .then(() => {
                    console.log(animationInfo);
                    drawFrames(animationInfo.sheet.get(0),animationInfo.cgg,animationInfo.cgs.atk);

                })
            
        }

        //need animInfo for bounds checking
        function drawFrames(spritesheet,cggData,animInfo){
            d3.select("#frameContainer canvas").remove();

            let actualFrames = []; //frames to draw

            //analyze bounds - to refactor
            let xMin,yMin,xMax,yMax,wMin,wMax,hMin,hMax;
            for(let i of animInfo){
                let frameData = cggData[i.frame_index];
                actualFrames.push(frameData);
                for(let f of frameData.frame_data){
                    //set mins
                    !isNaN(xMin) ? (xMin = Math.min(xMin,f.position.x)) : (xMin = f.position.x);
                    !isNaN(yMin) ? (yMin = Math.min(yMin,f.position.y)) : (yMin = f.position.y);
                    !isNaN(wMin) ? (wMin = Math.min(wMin,f.img.width)) : (wMin = f.img.width);
                    !isNaN(hMin) ? (hMin = Math.min(hMin,f.img.height)) : (hMin = f.img.height);

                    //set max
                    !isNaN(xMax) ? (xMax = Math.max(xMax,f.position.x)) : (xMax = f.position.x);
                    !isNaN(yMax) ? (yMax = Math.max(yMax,f.position.y)) : (yMax = f.position.y);
                    !isNaN(wMax) ? (wMax = Math.max(wMax,f.img.width)) : (wMax = f.img.width);
                    !isNaN(hMax) ? (hMax = Math.max(hMax,f.img.height)) : (hMax = f.img.height);

                }

            }
            //store bounds
            const bounds = {
                x: [xMin,xMax],
                y: [yMin,yMax],
                w: [wMin,wMax],
                h: [hMin,hMax],
                frame: {
                    x: [xMin, xMax + wMax],
                    y: [yMin, yMax + hMax]
                }
            };

            const frameBounds = {
                x: [Math.min(xMin, xMax - wMax), xMax + wMax],
                y: [Math.min(yMin, yMax - hMax), yMax + hMax],
                w: xMax + wMax - Math.min(xMin, xMax - wMax),
                h: yMax + hMax - Math.min(yMin, yMax - hMax),
                offset: {//add to move sprite to right/bottom, add half to center
                    x: xMax - Math.min(xMin, xMax - wMax), 
                    y: yMax - Math.min(yMin, yMax - hMax)
                }
            };
            console.log(bounds)

            d3.select("#frameContainer").selectAll('canvas')
                .data(actualFrames).enter().append('canvas')
                .attr('width', frameBounds.w).attr('height',frameBounds.h)
                .each(function(data,index,domArray){
                    drawFrame(data, domArray[index], spritesheet, frameBounds);
                });
        }

        function drawFrame(frameData, targetCanvas, sourceSheet, frameBounds){
            const origin = {
                x: targetCanvas.width / 2,
                y: targetCanvas.height / 2
            };
            let context = targetCanvas.getContext('2d');
            console.log(arguments)

            // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
            for(let i = frameData.frame_data.length - 1; i >= 0; --i){
                let f = frameData.frame_data[i]; //draw in reverse order
                const w = f.img.width, h = f.img.height
                context.drawImage(
                    sourceSheet,
                    f.img.x,f.img.y,w,h,
                    f.position.x + origin.x + frameBounds.offset.x/2, f.position.y + origin.y + frameBounds.offset.y,w,h
                );
            }


        }


        $(document).ready(() => {
            animationInfo.sheet = $("#sheetContainer img");

            animationInfo.sheet.on('load', handleSpritesheetLoad);

            animationInfo.sheet.attr('src', "test/unit_anime_10011.png");
        })
    </script>
</body>

</html>